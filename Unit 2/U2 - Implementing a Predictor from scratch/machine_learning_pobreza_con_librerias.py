# -*- coding: utf-8 -*-
"""Machine_Learning- pobreza-con_librerias.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Yd768VLQn_8KzPlRHygEXql_EeOAQ90G

# Codigo con librerias en diferentes celdas
"""

#Librerias a utilizar
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score

# Configurar la salida para mostrar todas las filas y columnas (esto es para verlo mejor en el colab)
pd.set_option('display.max_rows', None)
pd.set_option('display.max_columns', None)
pd.set_option('display.width', None)
pd.set_option('display.max_colwidth', None)

# Cargar el Dataset
csv_path = '/content/Indicadores_municipales_sabana_DA.csv'
df = pd.read_csv(csv_path, encoding='latin-1')

# Rellenar los valores faltantes con 0 o el valor adecuado
df = df.fillna(0)

X = df[['N_ic_rezedu']]  # Ajusta estas columnas a las que vamos usar
y = df['N_ic_rezedu']  # La columna donde sacaremos los datos

# Divide los datos en conjuntos de entrenamiento y prueba (80% - 20%)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=50)

# Inicializar el modelo KNN con un valor de k (n_neighbors)
knn = KNeighborsClassifier(n_neighbors=5)  # Ajusta el valor de k según tus necesidades

# Ajustar el modelo a los datos de entrenamiento
knn.fit(X_train, y_train)

# Realizar predicciones en los datos de prueba
y_pred = knn.predict(X_test)
df = pd.DataFrame(df)

# Agrupar por valores de la primera columna (Col1)
grupo = df.groupby('ent')

# Calcular la suma de la quinta columna (Col6) para cada grupo
suma_col6 = grupo['N_ic_rezedu'].sum()

# Calcular la media para cada grupo
media_por_grupo = suma_col6 / grupo.size()

# Calcular la media final
media_final = media_por_grupo.mean()

suma_1 = df['N_ic_rezedu'].sum()

# Media de la columna
media_1 = df['N_ic_rezedu'].mean()

# Calcular el valor mínimo, medio y máximo de los grupos

valor_minimo = media_final /2
valor_medio = media_final


# Calcular el valor mínimo, medio y máximo de los datos que utilizaremos

valor_minimo_1 = media_1 / 2
valor_medio_1 = media_1

# Clasificar en "bajo", "medio" y "alto" según la suma de Col6
def clasificar(suma):
    if suma <= valor_minimo:
        return 'Bajo'
    elif suma <= valor_medio:
        return 'Medio'
    else:
        return 'Alto'

clasificacion = suma_col6.apply(clasificar)


# Clasificar los Valores Reales como "Bajo", "Medio" o "Alto"
def clasificar_reales(suma):
    if suma <= valor_minimo_1:
        return 'Bajo'
    elif suma <= valor_medio_1:
        return 'Medio'
    else:
        return 'Alto'

y_test_clasificado = y_test.apply(clasificar_reales)

# Aplicar la clasificación a los datos de prueba
y_pred_clasificado = [clasificar(suma) for suma in y_pred]

# Asociar la clasificación con los valores reales
resultados = pd.DataFrame({'Predicciones': y_pred_clasificado, 'Valores Reales': y_test_clasificado})
print(resultados)

# Calcular el porcentaje de precisión
precision = accuracy_score(y_test_clasificado, y_pred_clasificado)

# Imprimir el porcentaje de precisión
print(f'Porcentaje de precisión: {precision * 100:.2f}%')

"""# codigo con librerias en una celda"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score

# Configurar la salida para mostrar todas las filas y columnas
pd.set_option('display.max_rows', None)
pd.set_option('display.max_columns', None)
pd.set_option('display.width', None)
pd.set_option('display.max_colwidth', None)


# Cargar el Dataset
csv_path = '/content/Indicadores_municipales_sabana_DA.csv'
df = pd.read_csv(csv_path, encoding='latin-1')

# Rellenar los valores faltantes con 0 o el valor adecuado
df = df.fillna(0)

# Seleccionar las columnas de características (X) y la columna objetivo (y)
X = df[['N_ic_rezedu']]  # Ajusta estas columnas a las que vamos usar
y = df['N_ic_rezedu']  # La columna donde sacaremos los datos

# Divide los datos en conjuntos de entrenamiento y prueba (80% - 20%)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=50)

# Inicializar el modelo KNN con un valor de k (n_neighbors)
knn = KNeighborsClassifier(n_neighbors=5)  # Ajusta el valor de k según tus necesidades

# Ajustar el modelo a los datos de entrenamiento
knn.fit(X_train, y_train)

# Realizar predicciones en los datos de prueba
y_pred = knn.predict(X_test)
df = pd.DataFrame(df)

# Agrupar por valores de la primera columna (Col1)
grupo = df.groupby('ent')

# Calcular la suma de la quinta columna (Col6) para cada grupo
suma_col6 = grupo['N_ic_rezedu'].sum()

# Calcular la media para cada grupo
media_por_grupo = suma_col6 / grupo.size()

# Calcular la media final
media_final = media_por_grupo.mean()

suma_1 = df['N_ic_rezedu'].sum()

# Media de la columna
media_1 = df['N_ic_rezedu'].mean()

# Calcular el valor mínimo, medio y máximo de los grupos

valor_minimo = media_final /2
valor_medio = media_final


# Calcular el valor mínimo, medio y máximo de los datos que utilizaremos

valor_minimo_1 = media_1 / 2
valor_medio_1 = media_1





# Clasificar en "bajo", "medio" y "alto" según la suma de Col6
def clasificar(suma):
    if suma <= valor_minimo:
        return 'Bajo'
    elif suma <= valor_medio:
        return 'Medio'
    else:
        return 'Alto'

clasificacion = suma_col6.apply(clasificar)


# Clasificar los Valores Reales como "Bajo", "Medio" o "Alto"
def clasificar_reales(suma):
    if suma <= valor_minimo_1:
        return 'Bajo'
    elif suma <= valor_medio_1:
        return 'Medio'
    else:
        return 'Alto'

y_test_clasificado = y_test.apply(clasificar_reales)

# Aplicar la clasificación a los datos de prueba
y_pred_clasificado = [clasificar(suma) for suma in y_pred]

# Asociar la clasificación con los valores reales
resultados = pd.DataFrame({'Predicciones': y_pred_clasificado, 'Valores Reales': y_test_clasificado})
print(resultados)

# Calcular el porcentaje de precisión
precision = accuracy_score(y_test_clasificado, y_pred_clasificado)

# Imprimir el porcentaje de precisión
print(f'Porcentaje de precisión: {precision * 100:.2f}%')